// Code generated by go-swagger; DO NOT EDIT.

package preheat

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery -name API -inpkg

// API is the interface of the preheat client
type API interface {
	/*
	   CreateInstance creates p2p provider instances

	   Create p2p provider instances*/
	CreateInstance(ctx context.Context, params *CreateInstanceParams) (*CreateInstanceCreated, error)
	/*
	   CreatePolicy creates a preheat policy under a project

	   Create a preheat policy under a project*/
	CreatePolicy(ctx context.Context, params *CreatePolicyParams) (*CreatePolicyCreated, error)
	/*
	   DeleteInstance deletes the specified p2 p provider instance

	   Delete the specified P2P provider instance*/
	DeleteInstance(ctx context.Context, params *DeleteInstanceParams) (*DeleteInstanceOK, error)
	/*
	   DeletePolicy deletes a preheat policy

	   Delete a preheat policy*/
	DeletePolicy(ctx context.Context, params *DeletePolicyParams) (*DeletePolicyOK, error)
	/*
	   GetExecution gets a execution detail by id

	   Get a execution detail by id*/
	GetExecution(ctx context.Context, params *GetExecutionParams) (*GetExecutionOK, error)
	/*
	   GetInstance gets a p2 p provider instance

	   Get a P2P provider instance*/
	GetInstance(ctx context.Context, params *GetInstanceParams) (*GetInstanceOK, error)
	/*
	   GetPolicy gets a preheat policy

	   Get a preheat policy*/
	GetPolicy(ctx context.Context, params *GetPolicyParams) (*GetPolicyOK, error)
	/*
	   GetPreheatLog gets the log text stream of the specified task for the given execution

	   Get the log text stream of the specified task for the given execution*/
	GetPreheatLog(ctx context.Context, params *GetPreheatLogParams) (*GetPreheatLogOK, error)
	/*
	   ListExecutions lists executions for the given policy

	   List executions for the given policy*/
	ListExecutions(ctx context.Context, params *ListExecutionsParams) (*ListExecutionsOK, error)
	/*
	   ListInstances lists p2 p provider instances

	   List P2P provider instances*/
	ListInstances(ctx context.Context, params *ListInstancesParams) (*ListInstancesOK, error)
	/*
	   ListPolicies lists preheat policies

	   List preheat policies*/
	ListPolicies(ctx context.Context, params *ListPoliciesParams) (*ListPoliciesOK, error)
	/*
	   ListProviders lists p2 p providers

	   List P2P providers*/
	ListProviders(ctx context.Context, params *ListProvidersParams) (*ListProvidersOK, error)
	/*
	   ListProvidersUnderProject gets all providers at project level

	   Get all providers at project level*/
	ListProvidersUnderProject(ctx context.Context, params *ListProvidersUnderProjectParams) (*ListProvidersUnderProjectOK, error)
	/*
	   ListTasks lists all the related tasks for the given execution

	   List all the related tasks for the given execution*/
	ListTasks(ctx context.Context, params *ListTasksParams) (*ListTasksOK, error)
	/*
	   ManualPreheat manuals preheat

	   Manual preheat*/
	ManualPreheat(ctx context.Context, params *ManualPreheatParams) (*ManualPreheatCreated, error)
	/*
	   PingInstances pings status of a instance

	   This endpoint checks status of a instance, the instance can be given by ID or Endpoint URL (together with credential)
	*/
	PingInstances(ctx context.Context, params *PingInstancesParams) (*PingInstancesOK, error)
	/*
	   StopExecution stops a execution

	   Stop a execution*/
	StopExecution(ctx context.Context, params *StopExecutionParams) (*StopExecutionOK, error)
	/*
	   UpdateInstance updates the specified p2 p provider instance

	   Update the specified P2P provider instance*/
	UpdateInstance(ctx context.Context, params *UpdateInstanceParams) (*UpdateInstanceOK, error)
	/*
	   UpdatePolicy updates preheat policy

	   Update preheat policy*/
	UpdatePolicy(ctx context.Context, params *UpdatePolicyParams) (*UpdatePolicyOK, error)
}

// New creates a new preheat API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for preheat API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
CreateInstance creates p2p provider instances

Create p2p provider instances
*/
func (a *Client) CreateInstance(ctx context.Context, params *CreateInstanceParams) (*CreateInstanceCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateInstance",
		Method:             "POST",
		PathPattern:        "/p2p/preheat/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateInstanceCreated), nil

}

/*
CreatePolicy creates a preheat policy under a project

Create a preheat policy under a project
*/
func (a *Client) CreatePolicy(ctx context.Context, params *CreatePolicyParams) (*CreatePolicyCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreatePolicy",
		Method:             "POST",
		PathPattern:        "/projects/{project_name}/preheat/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreatePolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreatePolicyCreated), nil

}

/*
DeleteInstance deletes the specified p2 p provider instance

Delete the specified P2P provider instance
*/
func (a *Client) DeleteInstance(ctx context.Context, params *DeleteInstanceParams) (*DeleteInstanceOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteInstance",
		Method:             "DELETE",
		PathPattern:        "/p2p/preheat/instances/{preheat_instance_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteInstanceOK), nil

}

/*
DeletePolicy deletes a preheat policy

Delete a preheat policy
*/
func (a *Client) DeletePolicy(ctx context.Context, params *DeletePolicyParams) (*DeletePolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeletePolicy",
		Method:             "DELETE",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeletePolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeletePolicyOK), nil

}

/*
GetExecution gets a execution detail by id

Get a execution detail by id
*/
func (a *Client) GetExecution(ctx context.Context, params *GetExecutionParams) (*GetExecutionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetExecution",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetExecutionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetExecutionOK), nil

}

/*
GetInstance gets a p2 p provider instance

Get a P2P provider instance
*/
func (a *Client) GetInstance(ctx context.Context, params *GetInstanceParams) (*GetInstanceOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetInstance",
		Method:             "GET",
		PathPattern:        "/p2p/preheat/instances/{preheat_instance_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetInstanceOK), nil

}

/*
GetPolicy gets a preheat policy

Get a preheat policy
*/
func (a *Client) GetPolicy(ctx context.Context, params *GetPolicyParams) (*GetPolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPolicy",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPolicyOK), nil

}

/*
GetPreheatLog gets the log text stream of the specified task for the given execution

Get the log text stream of the specified task for the given execution
*/
func (a *Client) GetPreheatLog(ctx context.Context, params *GetPreheatLogParams) (*GetPreheatLogOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPreheatLog",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks/{task_id}/logs",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPreheatLogReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPreheatLogOK), nil

}

/*
ListExecutions lists executions for the given policy

List executions for the given policy
*/
func (a *Client) ListExecutions(ctx context.Context, params *ListExecutionsParams) (*ListExecutionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListExecutions",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListExecutionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListExecutionsOK), nil

}

/*
ListInstances lists p2 p provider instances

List P2P provider instances
*/
func (a *Client) ListInstances(ctx context.Context, params *ListInstancesParams) (*ListInstancesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListInstances",
		Method:             "GET",
		PathPattern:        "/p2p/preheat/instances",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListInstancesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListInstancesOK), nil

}

/*
ListPolicies lists preheat policies

List preheat policies
*/
func (a *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams) (*ListPoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListPolicies",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListPoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListPoliciesOK), nil

}

/*
ListProviders lists p2 p providers

List P2P providers
*/
func (a *Client) ListProviders(ctx context.Context, params *ListProvidersParams) (*ListProvidersOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListProviders",
		Method:             "GET",
		PathPattern:        "/p2p/preheat/providers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProvidersReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListProvidersOK), nil

}

/*
ListProvidersUnderProject gets all providers at project level

Get all providers at project level
*/
func (a *Client) ListProvidersUnderProject(ctx context.Context, params *ListProvidersUnderProjectParams) (*ListProvidersUnderProjectOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListProvidersUnderProject",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/providers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProvidersUnderProjectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListProvidersUnderProjectOK), nil

}

/*
ListTasks lists all the related tasks for the given execution

List all the related tasks for the given execution
*/
func (a *Client) ListTasks(ctx context.Context, params *ListTasksParams) (*ListTasksOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ListTasks",
		Method:             "GET",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}/tasks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListTasksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListTasksOK), nil

}

/*
ManualPreheat manuals preheat

Manual preheat
*/
func (a *Client) ManualPreheat(ctx context.Context, params *ManualPreheatParams) (*ManualPreheatCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ManualPreheat",
		Method:             "POST",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ManualPreheatReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ManualPreheatCreated), nil

}

/*
PingInstances pings status of a instance

This endpoint checks status of a instance, the instance can be given by ID or Endpoint URL (together with credential)
*/
func (a *Client) PingInstances(ctx context.Context, params *PingInstancesParams) (*PingInstancesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PingInstances",
		Method:             "POST",
		PathPattern:        "/p2p/preheat/instances/ping",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PingInstancesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PingInstancesOK), nil

}

/*
StopExecution stops a execution

Stop a execution
*/
func (a *Client) StopExecution(ctx context.Context, params *StopExecutionParams) (*StopExecutionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "StopExecution",
		Method:             "PATCH",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}/executions/{execution_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopExecutionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*StopExecutionOK), nil

}

/*
UpdateInstance updates the specified p2 p provider instance

Update the specified P2P provider instance
*/
func (a *Client) UpdateInstance(ctx context.Context, params *UpdateInstanceParams) (*UpdateInstanceOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateInstance",
		Method:             "PUT",
		PathPattern:        "/p2p/preheat/instances/{preheat_instance_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateInstanceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateInstanceOK), nil

}

/*
UpdatePolicy updates preheat policy

Update preheat policy
*/
func (a *Client) UpdatePolicy(ctx context.Context, params *UpdatePolicyParams) (*UpdatePolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdatePolicy",
		Method:             "PUT",
		PathPattern:        "/projects/{project_name}/preheat/policies/{preheat_policy_name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdatePolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdatePolicyOK), nil

}
